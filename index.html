<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Keyboard Text Player</title>
  <!-- External CSS -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="style.css">
  <link rel="stylesheet" href="piano.css">
</head>
<body>
  <div class="app-container">
    <header class="app-header">
      <h1>Keyboard Text Player</h1>
      <p class="app-subtitle">Load a converted score and play it with your keyboard.</p>
    </header>

    <div class="file-row">
      <input type="file" id="fileInput">
      <span id="selectedFileName" class="file-name">No file loaded</span>
    </div>

    <div id="controls" class="control-bar">
      <div class="button-group">
        <button id="playBtn">Play</button>
        <button id="stopBtn">Stop</button>
        <button id="transposeUp">Transpose +</button>
        <button id="transposeDown">Transpose -</button>
        <button id="transposeReset">Reset</button>
      </div>
      <div class="control-group">
        <label for="bpmInput">Tempo (BPM)</label>
        <input type="number" id="bpmInput" min="30" max="300" value="120" step="1">
      </div>
      <div class="control-group">
        <label for="volumeSlider">Volume</label>
        <div class="slider-wrapper">
          <input type="range" id="volumeSlider" min="-40" max="0" value="0" step="1">
          <span id="volumeValue" class="value-tag">0 dB</span>
        </div>
      </div>
    </div>

    <p class="transpose-indicator">Transpose: <span id="transposeValue">0</span> semitones</p>
    <div id="output" class="output-panel"></div>
    <div id="piano"></div>
  </div>

  <!-- Tone.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
  
  <script>
    const DEFAULT_DURATION_BEATS = 0.5;
    const DEFAULT_BPM = 120;
    const BPM_MIN = 30;
    const BPM_MAX = 300;
    const DEFAULT_TIME_SIGNATURE = '4/4';

    let bpm = DEFAULT_BPM;
    let tokens = [];
    let spans = [];
    let midiOut = null;
    let useTone = true;
    let midiToKeyElement = {};

    let transpose = 0;
    let playTimeout = null;
    let isPlaying = false;
    let currentIndex = 0;
    let expectedNotes = [];
    let sequenceProgress = 0;
    let lastFile = null;
    let scheduledTimeouts = [];
    let fileNameLabel = null;

    const piano = new Tone.Sampler({
      urls: {
        A0: "A0.mp3", C1: "C1.mp3",
        A1: "A1.mp3", C2: "C2.mp3",
        A2: "A2.mp3", C3: "C3.mp3",
        A3: "A3.mp3", C4: "C4.mp3",
        A4: "A4.mp3", C5: "C5.mp3",
        A5: "A5.mp3", C6: "C6.mp3",
        A6: "A6.mp3", C7: "C7.mp3",
        A7: "A7.mp3", C8: "C8.mp3"
      },
      release: 2,
      baseUrl: "https://gleitz.github.io/midi-js-soundfonts/MusyngKite/acoustic_grand_piano-mp3/"
    }).toDestination();

    const volumeSlider = document.getElementById('volumeSlider');
    const volumeValue = document.getElementById('volumeValue');

    if (volumeSlider && volumeValue) {
      const updateVolume = (db) => {
        piano.volume.value = db;
        volumeValue.textContent = db + ' dB';
      };

      updateVolume(Number(volumeSlider.value));

      volumeSlider.addEventListener('input', (event) => {
        updateVolume(Number(event.target.value));
      });
    }

    const keyToMidi = {
      '1':36, '!':37, '2':38, '@':39, '3':40, '#':40, '4':41, '$':42, '5':43, '%':44,
      '6':45, '^':46, '7':47, '&':47, '8':48, '*':49, '9':50, '(':51, '0':52, ')':52,
      'q':53, 'Q':54, 'w':55, 'W':56, 'e':57, 'E':58, 'r':59, 'R':59, 't':60, 'T':61,
      'y':62, 'Y':63, 'u':64, 'U':64, 'i':65, 'I':66, 'o':67, 'O':68, 'p':69, 'P':70,
      'a':71, 'A':71, 's':72, 'S':73, 'd':74, 'D':75, 'f':76, 'F':76, 'g':77, 'G':78,
      'h':79, 'H':80, 'j':81, 'J':82, 'k':83, 'K':83, 'l':84, 'L':85,
      'z':86, 'Z':87, 'x':88, 'X':88, 'c':89, 'C':90, 'v':91, 'V':92,
      'b':93, 'B':94, 'n':95, 'N':95, 'm':96, 'M':97
    };

    const midiToKey = {};
    for (const [key, value] of Object.entries(keyToMidi)) {
      midiToKey[value] = key;
    }

    function buildPiano() {
      const container = document.getElementById('piano');
      if (!container) return;
      container.innerHTML = '';

      const keysWrapper = document.createElement('div');
      keysWrapper.className = 'piano-keys';
      container.appendChild(keysWrapper);

      const startMidi = 21;
      const endMidi = 108;
      const whiteWidth = 26;
      const blackWidth = 18;
      const blackHeight = 70;
      const whiteHeight = 102;

      const blackNotes = {1:true, 3:true, 6:true, 8:true, 10:true};

      let whiteIndex = 0;
      for (let midi = startMidi; midi <= endMidi; midi++) {
        const pitchClass = midi % 12;
        if (!blackNotes[pitchClass]) {
          const whiteKey = document.createElement('div');
          whiteKey.className = 'white';
          whiteKey.style.left = (whiteIndex * whiteWidth) + 'px';
          whiteKey.style.width = whiteWidth + 'px';
          whiteKey.style.height = whiteHeight + 'px';
          keysWrapper.appendChild(whiteKey);
          midiToKeyElement[midi] = whiteKey;
          whiteIndex++;
        } else {
          const blackKey = document.createElement('div');
          blackKey.className = 'black';
          const offset = (whiteIndex * whiteWidth) - (blackWidth / 2);
          blackKey.style.left = offset + 'px';
          blackKey.style.width = blackWidth + 'px';
          blackKey.style.height = blackHeight + 'px';
          keysWrapper.appendChild(blackKey);
          midiToKeyElement[midi] = blackKey;
        }
      }

      const keysWidth = whiteIndex * whiteWidth;
      keysWrapper.style.width = keysWidth + 'px';
    }
    buildPiano();

    document.getElementById('transposeUp').addEventListener('click', () => {
      transpose = Math.min(transpose + 1, 12);
      document.getElementById('transposeValue').textContent = transpose;
    });
    document.getElementById('transposeDown').addEventListener('click', () => {
      transpose = Math.max(transpose - 1, -12);
      document.getElementById('transposeValue').textContent = transpose;
    });
    document.getElementById('transposeReset').addEventListener('click', () => {
      transpose = 0;
      document.getElementById('transposeValue').textContent = transpose;
    });

    function applyTranspose(note) {
      if (note === undefined || note === null) return null;
      const shifted = note + transpose;
      return Math.max(21, Math.min(108, shifted));
    }

    const NOTE_REFERENCES = [
      { beats: 4, label: '1' },
      { beats: 3, label: '2.' },
      { beats: 2, label: '2' },
      { beats: 1.5, label: '4.' },
      { beats: 1, label: '4' },
      { beats: 0.75, label: '8.' },
      { beats: 0.5, label: '8' },
      { beats: 0.375, label: '16.' },
      { beats: 0.25, label: '16' },
      { beats: 0.1875, label: '32.' },
      { beats: 0.125, label: '32' }
    ];
    const NOTE_TOLERANCE = 0.05;

    function beatsToNoteLabel(beats) {
      if (!Number.isFinite(beats) || beats <= 0) return '';
      for (const ref of NOTE_REFERENCES) {
        if (Math.abs(ref.beats - beats) <= NOTE_TOLERANCE) {
          return ref.label;
        }
      }
      const denom = 4 / beats;
      if (Number.isFinite(denom) && denom > 0) {
        const rounded = Math.round(denom);
        if (rounded > 0 && rounded <= 128) {
          return String(rounded);
        }
      }
      return beats.toFixed(2).replace(/\.0+$/, '');
    }

    function normalizeBpm(raw) {
      const value = Number(raw);
      if (!Number.isFinite(value) || value <= 0) return DEFAULT_BPM;
      return Math.min(BPM_MAX, Math.max(BPM_MIN, value));
    }

    function applyBpmFromInput(newValue) {
      bpm = normalizeBpm(newValue);
      if (bpmInput) {
        bpmInput.value = String(bpm);
      }
    }

    function updateFileNameDisplay(name) {
      if (!fileNameLabel) return;
      if (name) {
        fileNameLabel.textContent = name;
        fileNameLabel.classList.add('has-file');
      } else {
        fileNameLabel.textContent = 'No file loaded';
        fileNameLabel.classList.remove('has-file');
      }
    }

    function parseTokenString(tokenStr) {
      if (!tokenStr) return null;
      const [symbolPart, durationPartRaw] = tokenStr.split('|');
      const symbol = symbolPart || tokenStr;
      const type = symbol === '_' ? 'rest' : symbol.startsWith('[') ? 'chord' : symbol.startsWith('{') ? 'sequence' : 'single';
      const chars = type === 'rest'
        ? []
        : type === 'single'
          ? [symbol]
          : symbol.replace(/[{}\[\]]/g, '').split('');

      let durations = [];
      let waitBeats = null;

      if (durationPartRaw) {
        const [durSegment, waitSegment] = durationPartRaw.split(';');
        if (durSegment) {
          durations = durSegment.split(',').map(raw => {
            const value = Number(raw);
            return Number.isFinite(value) ? Math.max(value, 0) : DEFAULT_DURATION_BEATS;
          }).filter(value => value > 0);
        }
        if (waitSegment) {
          const waitValue = Number(waitSegment);
          if (Number.isFinite(waitValue) && waitValue > 0) {
            waitBeats = waitValue;
          }
        }
      }

      if (type === 'sequence') {
        if (!durations.length) {
          durations = new Array(chars.length).fill(DEFAULT_DURATION_BEATS);
        } else if (durations.length !== chars.length) {
          const last = durations[durations.length - 1] || DEFAULT_DURATION_BEATS;
          while (durations.length < chars.length) {
            durations.push(last);
          }
          durations = durations.slice(0, chars.length);
        }
      } else if (type === 'rest') {
        durations = [];
      } else {
        if (!durations.length) {
          durations = [DEFAULT_DURATION_BEATS];
        } else {
          durations = [durations[0]];
        }
      }

      const durationSum = durations.reduce((total, value) => total + (Number.isFinite(value) ? value : 0), 0);
      if (!Number.isFinite(waitBeats) || waitBeats <= 0) {
        waitBeats = type === 'rest' ? (durationSum || DEFAULT_DURATION_BEATS) : Math.max(durationSum, DEFAULT_DURATION_BEATS);
      }

      return {
        original: tokenStr,
        symbol,
        type,
        chars,
        durations,
        waitBeats
      };
    }

    function getBeatDurationMs() {
      const current = Number.isFinite(bpm) && bpm > 0 ? bpm : DEFAULT_BPM;
      const clamped = Math.min(BPM_MAX, Math.max(BPM_MIN, current));
      return 60000 / clamped;
    }

    function durationToMs(beats) {
      const value = Number.isFinite(beats) && beats > 0 ? beats : DEFAULT_DURATION_BEATS;
      return Math.max(20, value * getBeatDurationMs());
    }

    function sumDurations(token) {
      if (!token || !token.durations || !token.durations.length) return DEFAULT_DURATION_BEATS;
      return token.durations.reduce((total, value) => total + (Number.isFinite(value) ? value : 0), 0) || DEFAULT_DURATION_BEATS;
    }

    function makeDurationLabel(token) {
      if (!token) return '';
      if (token.type === 'rest') {
        return beatsToNoteLabel(token.waitBeats);
      }
      if (token.type === 'sequence') {
        return token.durations.map(beatsToNoteLabel).join(',');
      }
      if (token.durations.length) {
        return beatsToNoteLabel(token.durations[0]);
      }
      return '';
    }

    function renderTokens() {
      const out = document.getElementById('output');
      out.innerHTML = '';
      spans = tokens.map((token, index) => {
        const wrapper = document.createElement('span');
        wrapper.className = 'token';

        const symbolSpan = document.createElement('span');
        symbolSpan.className = 'token-symbol';
        symbolSpan.textContent = token.symbol;

        const label = makeDurationLabel(token);
        if (label) {
          const sub = document.createElement('sub');
          sub.className = 'token-duration';
          sub.textContent = label;
          symbolSpan.appendChild(sub);
        }

        wrapper.appendChild(symbolSpan);
        out.appendChild(wrapper);
        if (index < tokens.length - 1) {
          out.appendChild(document.createTextNode(' '));
        }
        return wrapper;
      });

      currentIndex = 0;
      expectedNotes = [];
      sequenceProgress = 0;
      setTarget(true);
    }

    function scheduleTimeout(callback, delay) {
      const id = setTimeout(() => {
        scheduledTimeouts = scheduledTimeouts.filter(handle => handle !== id);
        callback();
      }, delay);
      scheduledTimeouts.push(id);
      return id;
    }

    function clearScheduledTimeouts() {
      scheduledTimeouts.forEach(id => clearTimeout(id));
      scheduledTimeouts = [];
    }

    function stopAllNotes() {
      if (midiOut && !useTone) {
        try {
          midiOut.send([0xB0, 0x7B, 0]);
        } catch (error) {
          console.warn('Unable to send all-notes-off to MIDI output.', error);
        }
      }
      if (typeof piano.releaseAll === 'function') {
        piano.releaseAll();
      }
      Object.values(midiToKeyElement).forEach(el => el.classList.remove('active'));
    }

    function pauseAutoPlay() {
      if (playTimeout) {
        clearTimeout(playTimeout);
        playTimeout = null;
      }
      clearScheduledTimeouts();
      stopAllNotes();
      isPlaying = false;
      if (playButton) {
        playButton.textContent = 'Play';
      }
    }

    function stopAutoPlay(resetIndex = false) {
      pauseAutoPlay();
      if (resetIndex) {
        currentIndex = 0;
        setTarget(true);
      }
    }

    const fileInput = document.getElementById('fileInput');
    const playButton = document.getElementById('playBtn');
    const stopButton = document.getElementById('stopBtn');
    const bpmInput = document.getElementById('bpmInput');

    fileNameLabel = document.getElementById('selectedFileName');
    updateFileNameDisplay();

    const handleBpmInput = (event) => applyBpmFromInput(event.target.value);

    if (bpmInput) {
      applyBpmFromInput(bpmInput.value || DEFAULT_BPM);
      bpmInput.addEventListener('change', handleBpmInput);
      bpmInput.addEventListener('input', handleBpmInput);
    }

    function loadFile(file) {
      pauseAutoPlay();
      if (!file) {
        updateFileNameDisplay();
        return;
      }
      updateFileNameDisplay(file.name);
      const reader = new FileReader();
      reader.onload = function(event) {
        const rawText = (event.target.result || '').toString();
        const lines = rawText.split(/\r?\n/).map(line => line.trim());
        const filtered = lines.filter(line => line && !line.startsWith('#'));
        const flattened = filtered.join(' ');
        const rawTokens = flattened ? flattened.split(/\s+/) : [];
        tokens = rawTokens.map(parseTokenString).filter(Boolean);
        renderTokens();
      };
      reader.readAsText(file);
    }

    if (fileInput) {
      fileInput.addEventListener('change', (event) => {
        const file = event.target.files && event.target.files[0];
        if (!file) {
          updateFileNameDisplay();
          return;
        }
        lastFile = file;
        loadFile(file);
      });
    }

    if (stopButton) {
      stopButton.addEventListener('click', () => {
        stopAutoPlay(true);
        expectedNotes = [];
        sequenceProgress = 0;
        if (lastFile) {
          loadFile(lastFile);
        } else {
          updateFileNameDisplay();
          spans.forEach(span => span.classList.remove('highlight', 'wrong'));
        }
      });
    }

    function setTarget(skipRests = false) {
      spans.forEach(span => span.classList.remove('highlight', 'wrong'));
      if (currentIndex >= tokens.length) return;

      const token = tokens[currentIndex];
      if (!token) return;

      if (skipRests && token.type === 'rest') {
        currentIndex++;
        setTarget(skipRests);
        return;
      }

      const span = spans[currentIndex];
      if (span) {
        span.classList.add('highlight');
        const container = document.getElementById('output');
        if (container) {
          const targetTop = span.offsetTop - container.offsetTop - 12;
          container.scrollTo({ top: Math.max(targetTop, 0), behavior: 'smooth' });
        }
      }

      if (token.type === 'rest') {
        expectedNotes = [];
        sequenceProgress = 0;
        return;
      }

      const midiNotes = token.chars
        .map(character => applyTranspose(keyToMidi[character]))
        .filter(note => note !== null);

      if (token.type === 'chord') {
        expectedNotes = midiNotes.slice();
        sequenceProgress = 0;
      } else if (token.type === 'sequence') {
        expectedNotes = midiNotes.slice();
        sequenceProgress = 0;
      } else {
        expectedNotes = midiNotes.length ? [midiNotes[0]] : [];
        sequenceProgress = 0;
      }
    }

    function playToken(token) {
      if (!token) {
        return;
      }

      if (token.type === 'rest') {
        return;
      }

      if (token.type === 'chord') {
        const notes = token.chars
          .map(character => applyTranspose(keyToMidi[character]))
          .filter(note => note !== null);
        const holdMs = durationToMs(token.durations[0]);
        notes.forEach(note => noteOn(note));
        notes.forEach(note => scheduleTimeout(() => noteOff(note), holdMs));
        return;
      }

      if (token.type === 'sequence') {
        let elapsedBeats = 0;
        token.chars.forEach((character, index) => {
          const midiNote = applyTranspose(keyToMidi[character]);
          const beatLength = token.durations[index] || DEFAULT_DURATION_BEATS;
          if (midiNote !== null) {
            const delayMs = durationToMs(elapsedBeats);
            const lengthMs = durationToMs(beatLength);
            scheduleTimeout(() => noteOn(midiNote), delayMs);
            scheduleTimeout(() => noteOff(midiNote), delayMs + lengthMs);
          }
          elapsedBeats += beatLength;
        });
        return;
      }

      const midiNote = applyTranspose(keyToMidi[token.symbol]);
      const holdMs = durationToMs(token.durations[0]);
      if (midiNote !== null) {
        noteOn(midiNote);
        scheduleTimeout(() => noteOff(midiNote), holdMs);
      }
    }

    function startAutoPlay() {
      if (!isPlaying) return;
      if (currentIndex >= tokens.length) {
        stopAutoPlay(true);
        return;
      }

      setTarget(false);
      const token = tokens[currentIndex];
      playToken(token);

      const waitBeats = token.waitBeats ?? sumDurations(token);
      const waitMs = Math.max(50, durationToMs(waitBeats));
      currentIndex++;

      playTimeout = scheduleTimeout(() => {
        startAutoPlay();
      }, waitMs);
    }

    if (playButton) {
      playButton.addEventListener('click', async () => {
        if (!isPlaying) {
          if (!tokens.length) return;
          await Tone.start();
          isPlaying = true;
          playButton.textContent = 'Pause';
          clearScheduledTimeouts();
          startAutoPlay();
        } else {
          pauseAutoPlay();
        }
      });
    }

    function noteOn(note, velocity = 100) {
      if (!note) return;
      if (!useTone && midiOut) {
        midiOut.send([0x90, note, velocity]);
      } else {
        piano.triggerAttack(Tone.Frequency(note, 'midi'), undefined, velocity / 127);
      }
      if (midiToKeyElement[note]) {
        midiToKeyElement[note].classList.add('active');
        midiToKeyElement[note].scrollIntoView({ behavior: 'smooth', inline: 'center' });
      }
    }

    function noteOff(note) {
      if (!note) return;
      if (!useTone && midiOut) {
        midiOut.send([0x80, note, 0]);
      } else {
        piano.triggerRelease(Tone.Frequency(note, 'midi'));
      }
      if (midiToKeyElement[note]) {
        midiToKeyElement[note].classList.remove('active');
      }
    }

    if (navigator.requestMIDIAccess) {
      navigator.requestMIDIAccess().then(midiAccess => {
        const outputs = Array.from(midiAccess.outputs.values());
        if (outputs.length > 0) {
          midiOut = outputs[0];
          useTone = false;
        }
      });
    }

    document.addEventListener('keydown', event => {
      if (isPlaying) return;
      const key = event.key;
      if (!(key in keyToMidi)) return;

      const midiNote = applyTranspose(keyToMidi[key]);
      if (midiNote === null) return;

      noteOn(midiNote);
      setTimeout(() => noteOff(midiNote), 300);

      if (currentIndex >= tokens.length) return;
      const token = tokens[currentIndex];
      if (!token) return;

      if (token.type === 'rest') {
        currentIndex++;
        setTarget(true);
        return;
      }

      if (token.type === 'chord') {
        expectedNotes = expectedNotes.filter(note => note !== midiNote);
        if (expectedNotes.length === 0) {
          currentIndex++;
          setTarget(true);
        }
      } else if (token.type === 'sequence') {
        if (midiNote === expectedNotes[sequenceProgress]) {
          sequenceProgress++;
          if (sequenceProgress >= expectedNotes.length) {
            currentIndex++;
            setTarget(true);
          }
        } else {
          sequenceProgress = 0;
          if (spans[currentIndex]) {
            spans[currentIndex].classList.add('wrong');
            setTimeout(() => spans[currentIndex].classList.remove('wrong'), 200);
          }
        }
      } else {
        if (midiNote === expectedNotes[0]) {
          currentIndex++;
          setTarget(true);
        } else if (spans[currentIndex]) {
          spans[currentIndex].classList.add('wrong');
          setTimeout(() => spans[currentIndex].classList.remove('wrong'), 200);
        }
      }
    });
  </script>


</body>
</html>
